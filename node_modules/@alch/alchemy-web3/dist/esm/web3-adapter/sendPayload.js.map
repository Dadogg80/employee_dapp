{"version":3,"file":"sendPayload.js","sourceRoot":"","sources":["../../../src/web3-adapter/sendPayload.ts"],"names":[],"mappings":"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","sourcesContent":["import assertNever from \"assert-never\";\nimport {\n  Eip1193Provider,\n  FullConfig,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  Provider,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n} from \"../types\";\nimport { delay, promisify } from \"../util/promises\";\nimport { AlchemySendFunction } from \"./alchemySend\";\n\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\n  \"eth_accounts\",\n  \"eth_sendTransaction\",\n  \"eth_sign\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData\",\n  \"personal_sign\",\n];\n\nexport interface PayloadSender {\n  sendPayload: SendPayloadFunction;\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\n}\n\nexport interface SendPayloadFunction {\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\n}\n\nexport function makePayloadSender(\n  alchemySend: AlchemySendFunction,\n  config: FullConfig,\n): PayloadSender {\n  let currentWriteProvider = getEip1193Provider(config.writeProvider);\n\n  const sendPayload = (\n    payload: SingleOrBatchRequest,\n  ): Promise<SingleOrBatchResponse> => {\n    const disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendWithRetries(payload, alchemySend, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendWithProvider(currentWriteProvider, payload);\n        } catch {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\n          `No provider available for method \"${disallowedMethod}\"`,\n        );\n      }\n      return sendWithProvider(currentWriteProvider, payload);\n    }\n  };\n\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\n    currentWriteProvider = getEip1193Provider(writeProvider);\n  }\n\n  return { sendPayload: sendPayload as SendPayloadFunction, setWriteProvider };\n}\n\nfunction getEip1193Provider(\n  provider: Provider | null | undefined,\n): Eip1193Provider | undefined {\n  if (!provider) {\n    return undefined;\n  }\n  const anyProvider: any = provider;\n  let nextId = 0;\n  const sendMethod = (anyProvider.sendAsync\n    ? anyProvider.sendAsync\n    : anyProvider.send\n  ).bind(anyProvider);\n  return {\n    send: (method, params) =>\n      promisify(callback =>\n        sendMethod(\n          { jsonrpc: \"2.0\", id: `legacy:${nextId++}`, method, params },\n          callback,\n        ),\n      ),\n  };\n}\n\nfunction sendWithProvider(\n  provider: Eip1193Provider,\n  payload: SingleOrBatchRequest,\n): Promise<SingleOrBatchResponse> {\n  if (!Array.isArray(payload)) {\n    const { method, params } = payload;\n    return provider.send(method, params);\n  } else {\n    // These providers don't support batches, sadly.\n    return Promise.all(\n      payload.map(({ method, params }) => provider.send(method, params)),\n    );\n  }\n}\n\nfunction getDisallowedMethod(\n  payload: SingleOrBatchRequest,\n): string | undefined {\n  const payloads = Array.isArray(payload) ? payload : [payload];\n  const disallowedRequest =\n    payloads.find(p => ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0) ||\n    undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nasync function sendWithRetries(\n  payload: SingleOrBatchRequest,\n  alchemySend: AlchemySendFunction,\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\n): Promise<SingleOrBatchResponse> {\n  for (let i = 0; i < maxRetries + 1; i++) {\n    const result = await alchemySend(payload);\n    switch (result.type) {\n      case \"jsonrpc\":\n        return result.response;\n      case \"rateLimit\":\n        break;\n      case \"networkError\": {\n        const { status, message } = result;\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\n        throw new Error(`${statusString} ${message}`);\n      }\n      default:\n        return assertNever(result);\n    }\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n  }\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\n}\n"]}