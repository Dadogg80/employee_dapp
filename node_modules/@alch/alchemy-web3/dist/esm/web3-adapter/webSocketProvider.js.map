{"version":3,"file":"webSocketProvider.js","sourceRoot":"","sources":["../../../src/web3-adapter/webSocketProvider.ts"],"names":[],"mappings":"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","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  Backfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  makeBackfiller,\n  NewHeadsEvent,\n} from \"../subscriptions/subscriptionBackfill\";\nimport {\n  isSubscriptionEvent,\n  JsonRpcRequest,\n  SendFunction,\n  SubscriptionEvent,\n  WebSocketMessage,\n} from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport {\n  JsonRpcSenders,\n  makePayloadFactory,\n  makeSenders,\n} from \"../util/jsonRpc\";\nimport {\n  makeCancelToken,\n  throwIfCancelled,\n  withBackoffRetries,\n  withTimeout,\n} from \"../util/promises\";\nimport { SendPayloadFunction } from \"./sendPayload\";\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * This is the undocumented interface required by Web3 for providers which\n * handle subscriptions.\n *\n * In addition to the stated methods here, it communicates subscription events\n * by using EventEmitter#emit() to emit the events, with the appropriate\n * subscription id as the event type.\n */\nexport interface Web3SubscriptionProvider extends EventEmitter {\n  sendPayload: SendPayloadFunction;\n  send(method: string, params?: any[]): Promise<any>;\n  sendBatch(methods: any[], moduleInstance: any): Promise<any>;\n  supportsSubscriptions(): true;\n  subscribe(\n    subscribeMethod: string | undefined,\n    subscriptionMethod: string,\n    parameters: any[],\n  ): Promise<string>;\n  unsubscribe(\n    subscriptionId: string,\n    unsubscribeMethod?: string,\n  ): Promise<boolean>;\n  disconnect(code?: number, reason?: string): void;\n}\n\ninterface VirtualSubscription {\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"newHeads\"];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"logs\", LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport class AlchemyWebSocketProvider extends EventEmitter\n  implements Web3SubscriptionProvider {\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  private readonly virtualSubscriptionsById: Map<\n    string,\n    VirtualSubscription\n  > = new Map();\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  private readonly makePayload = makePayloadFactory();\n  private readonly senders: JsonRpcSenders;\n  private readonly backfiller: Backfiller;\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  private cancelBackfill = noop;\n\n  constructor(\n    private readonly ws: SturdyWebSocket,\n    public readonly sendPayload: SendPayloadFunction,\n  ) {\n    super();\n    this.senders = makeSenders(sendPayload, this.makePayload);\n    this.backfiller = makeBackfiller(this.senders);\n    this.send = this.senders.send;\n    this.addSocketListeners();\n    this.startHeartbeat();\n  }\n\n  public supportsSubscriptions(): true {\n    return true;\n  }\n\n  public async subscribe(\n    subscribeMethod = \"eth_subscribe\",\n    subscriptionMethod: string,\n    parameters: any[],\n  ): Promise<string> {\n    const method = subscribeMethod;\n    const params = [subscriptionMethod, ...parameters];\n    const startingBlockNumber = await this.getBlockNumber();\n    const id = await this.send(method, params);\n    this.virtualSubscriptionsById.set(id, {\n      method,\n      params,\n      startingBlockNumber,\n      virtualId: id,\n      physicalId: id,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: [],\n    });\n    this.virtualIdsByPhysicalId.set(id, id);\n    return id;\n  }\n\n  public async unsubscribe(\n    subscriptionId: string,\n    unsubscribeMethod = \"eth_unsubscribe\",\n  ): Promise<boolean> {\n    const virtualSubscription = this.virtualSubscriptionsById.get(\n      subscriptionId,\n    );\n    if (!virtualSubscription) {\n      return false;\n    }\n    const { physicalId } = virtualSubscription;\n    const response = await this.send(unsubscribeMethod, [physicalId]);\n    this.virtualSubscriptionsById.delete(subscriptionId);\n    this.virtualIdsByPhysicalId.delete(physicalId);\n    return response;\n  }\n\n  public disconnect(code?: number, reason?: string): void {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  }\n\n  // tslint:disable-next-line: member-ordering\n  public readonly send: SendFunction;\n\n  public sendBatch(methods: any[], moduleInstance: any): Promise<any> {\n    const payload: JsonRpcRequest[] = [];\n    methods.forEach(method => {\n      method.beforeExecution(moduleInstance);\n      payload.push(this.makePayload(method.rpcMethod, method.parameters));\n    });\n    return this.sendPayload(payload);\n  }\n\n  private addSocketListeners(): void {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private removeSocketListeners(): void {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private startHeartbeat = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(this.send(\"net_version\"), HEARTBEAT_WAIT_TIME);\n      } catch {\n        this.ws.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  };\n\n  private stopHeartbeatAndBackfill = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== \"eth_subscribe\") {\n      this.emitGenericEvent(virtualId, message.params.result);\n      return;\n    }\n    switch (subscription.params[0]) {\n      case \"newHeads\": {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitNewHeadsEvent(virtualId, result);\n        }\n        break;\n      }\n      case \"logs\": {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitLogsEvent(virtualId, result);\n        }\n        break;\n      }\n      default:\n        this.emitGenericEvent(virtualId, message.params.result);\n    }\n  };\n\n  private handleReopen = (): void => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error,\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription,\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber,\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case \"newHeads\": {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case \"logs\": {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach(event => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.send(\"eth_blockNumber\");\n    return fromHex(blockNumberHex);\n  }\n\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number,\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber,\n    );\n    this.emitGenericEvent(virtualId, result);\n  }\n\n  private emitGenericEvent(virtualId: string, result: any): void {\n    const event: SubscriptionEvent[\"params\"] = {\n      subscription: virtualId,\n      result,\n    };\n    this.emit(virtualId, event);\n  }\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number,\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    e => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT,\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction noop(): void {\n  // Nothing.\n}\n"]}