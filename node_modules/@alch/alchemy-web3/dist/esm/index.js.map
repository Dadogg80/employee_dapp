{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,OAAO,IAAI,MAAM,MAAM,CAAC;AAGxB,OAAO,EAAE,iBAAiB,EAAE,KAAK,EAAE,MAAM,YAAY,CAAC;AAEtD,OAAO,EAAE,YAAY,EAAE,MAAM,iBAAiB,CAAC;AAC/C,OAAO,EAAE,kBAAkB,EAAE,MAAM,+BAA+B,CAAC;AACnE,OAAO,4BAA4B,MAAM,6CAA6C,CAAC;AAEvF,IAAM,mBAAmB,GAAG,CAAC,CAAC;AAC9B,IAAM,sBAAsB,GAAG,IAAI,CAAC;AACpC,IAAM,oBAAoB,GAAG,GAAG,CAAC;AA0EjC,MAAM,CAAN,IAAY,sBAIX;AAJD,WAAY,sBAAsB;IAChC,+CAAqB,CAAA;IACrB,+CAAqB,CAAA;IACrB,yCAAe,CAAA;AACjB,CAAC,EAJW,sBAAsB,KAAtB,sBAAsB,QAIjC;AA2ED,MAAM,UAAU,iBAAiB,CAC/B,UAAkB,EAClB,MAA0B;IAE1B,IAAM,UAAU,GAAG,oBAAoB,CAAC,MAAM,CAAC,CAAC;IAC1C,IAAA,+CAGL,EAHO,sBAAQ,EAAE,sCAGjB,CAAC;IACF,IAAM,WAAW,GAAG,IAAI,IAAI,CAAC,QAAQ,CAAgB,CAAC;IACtD,WAAW,CAAC,WAAW,GAAG;QACxB,MAAM,IAAI,KAAK,CACb,uHAAuH,CACxH,CAAC;IACJ,CAAC,CAAC;IACF,WAAW,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;IAChD,IAAM,IAAI,GAAG,WAAW,CAAC,eAAe,CAAC,IAAI,CAAC,IAAI,CAChD,WAAW,CAAC,eAAe,CAC5B,CAAC;IACF,WAAW,CAAC,OAAO,GAAG;QACpB,iBAAiB,EAAE,UAAC,MAA4B,EAAE,QAAQ;YACxD,OAAA,iBAAiB,CAAC;gBAChB,IAAI,MAAA;gBACJ,QAAQ,UAAA;gBACR,MAAM,EAAE,2BAA2B;gBACnC,MAAM,EAAE,CAAC,MAAM,CAAC;aACjB,CAAC;QALF,CAKE;QACJ,gBAAgB,EAAE,UAAC,OAAO,EAAE,iBAAiB,EAAE,QAAQ;YACrD,OAAA,iBAAiB,CAAC;gBAChB,IAAI,MAAA;gBACJ,QAAQ,UAAA;gBACR,MAAM,EAAE,0BAA0B;gBAClC,MAAM,EAAE,CAAC,OAAO,EAAE,iBAAiB,CAAC;gBACpC,eAAe,EAAE,2BAA2B;aAC7C,CAAC;QANF,CAME;QACJ,gBAAgB,EAAE,UAAC,OAAO,EAAE,QAAQ;YAClC,OAAA,iBAAiB,CAAC;gBAChB,IAAI,MAAA;gBACJ,QAAQ,UAAA;gBACR,MAAM,EAAE,CAAC,OAAO,CAAC;gBACjB,MAAM,EAAE,0BAA0B;aACnC,CAAC;QALF,CAKE;QACJ,iBAAiB,EAAE,UAAC,MAA4B,EAAE,QAAQ;YACxD,OAAA,iBAAiB,CAAC;gBAChB,IAAI,MAAA;gBACJ,QAAQ,UAAA;gBACR,MAAM,EAAE;0CAED,MAAM,KACT,QAAQ,EACN,MAAM,CAAC,QAAQ,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS;iBAEjE;gBACD,MAAM,EAAE,2BAA2B;aACpC,CAAC;QAXF,CAWE;KACL,CAAC;IACF,kBAAkB,CAAC,WAAW,CAAC,CAAC;IAChC,OAAO,WAAW,CAAC;AACrB,CAAC;AAED,SAAS,oBAAoB,CAAC,EAKL;QALK,4BAKL,EAJvB,qBAAmC,EAAnC,wDAAmC,EACnC,kBAAgC,EAAhC,qDAAgC,EAChC,qBAAsC,EAAtC,2DAAsC,EACtC,mBAAkC,EAAlC,uDAAkC;IAElC,OAAO,EAAE,aAAa,eAAA,EAAE,UAAU,YAAA,EAAE,aAAa,eAAA,EAAE,WAAW,aAAA,EAAE,CAAC;AACnE,CAAC;AAED,SAAS,iBAAiB;IACxB,OAAO,OAAO,MAAM,KAAK,WAAW,CAAC,CAAC,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC;AAChE,CAAC;AAUD,SAAS,iBAAiB,CAAI,EAMD;IAN7B,iBAaC;QAZC,kBAAM,EACN,kBAAM,EACN,cAAI,EACJ,gBAAe,EAAf,oCAAe,EACf,uBAA0B,EAA1B,+CAA0B;IAE1B,IAAM,OAAO,GAAG,CAAC;;;;wBACA,qBAAM,IAAI,CAAC,MAAM,EAAE,MAAM,CAAC,EAAA;;oBAAnC,MAAM,GAAG,SAA0B;oBACzC,sBAAO,eAAe,CAAC,MAAM,CAAC,EAAC;;;SAChC,CAAC,EAAE,CAAC;IACL,YAAY,CAAC,OAAO,EAAE,QAAQ,CAAC,CAAC;IAChC,OAAO,OAAO,CAAC;AACjB,CAAC;AAED,SAAS,2BAA2B,CAClC,WAAkC;IAElC,kEAAkE;IAClE,IAAM,kBAAkB,GAAG,WAAW,CAAC,aAAa,CAAC,GAAG,CAAC,UAAA,OAAO;QAC9D,OAAA,OAAO,CAAC,YAAY,IAAI,IAAI;YAC1B,CAAC,uBAAM,OAAO,KAAE,YAAY,EAAE,iBAAiB,CAAC,OAAO,CAAC,YAAY,CAAC,IACrE,CAAC,CAAC,OAAO;IAFX,CAEW,CACZ,CAAC;IACF,6BAAY,WAAW,KAAE,aAAa,EAAE,kBAAkB,IAAG;AAC/D,CAAC;AAED;;;GAGG;AACH,SAAS,kBAAkB,CAAC,IAAU;IAC5B,IAAA,oDAAoB,CAAqB;IACjD,IAAM,kBAAkB,GAAG,oBAAoB,CAAC,eAAe,CAAC,IAAI,CAClE,oBAAoB,CACrB,CAAC;IACF,oBAAoB,CAAC,eAAe,GAAG;QAAC,cAAc;aAAd,UAAc,EAAd,qBAAc,EAAd,IAAc;YAAd,yBAAc;;QAC9C,IAAA,oBAA6B,EAA5B,sBAAc,EAAE,YAAY,CAAC;QACpC,IAAI,IAAI,KAAK,iCAAiC,EAAE;YAC9C,OAAO,IAAI,4BAA4B,CACrC,oBAAoB,CAAC,KAAK,EAC1B,oBAAoB,CAAC,UAAU,EAC/B,cAAc,CACf,CAAC;SACH;aAAM;YACL,OAAO,kBAAkB,wBAAI,IAAI,GAAE;SACpC;IACH,CAAC,CAAC;AACJ,CAAC;AAED,SAAS,IAAI;IACX,WAAW;AACb,CAAC;AAED,SAAS,QAAQ,CAAI,CAAI;IACvB,OAAO,CAAC,CAAC;AACX,CAAC","sourcesContent":["import Web3 from \"web3\";\nimport { Log, Transaction } from \"web3-core\";\nimport { BlockHeader, Eth, LogsOptions, Subscription, Syncing } from \"web3-eth\";\nimport { hexToNumberString, toHex } from \"web3-utils\";\nimport { AlchemyWeb3Config, FullConfig, Provider, Web3Callback } from \"./types\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nimport FullTransactionsSubscription from \"./web3-adapter/fullTransactionsSubscription\";\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_RETRY_INTERVAL = 1000;\nconst DEFAULT_RETRY_JITTER = 250;\n\nexport interface AlchemyWeb3 extends Web3 {\n  alchemy: AlchemyMethods;\n  eth: AlchemyEth;\n  setWriteProvider(provider: Provider | null | undefined): void;\n}\n\nexport interface AlchemyMethods {\n  getTokenAllowance(\n    params: TokenAllowanceParams,\n    callback?: Web3Callback<TokenAllowanceResponse>,\n  ): Promise<TokenAllowanceResponse>;\n  getTokenBalances(\n    address: string,\n    contractAddresses: string[],\n    callback?: Web3Callback<TokenBalancesResponse>,\n  ): Promise<TokenBalancesResponse>;\n  getTokenMetadata(\n    address: string,\n    callback?: Web3Callback<TokenMetadataResponse>,\n  ): Promise<TokenMetadataResponse>;\n  getAssetTransfers(\n    params: AssetTransfersParams,\n    callback?: Web3Callback<AssetTransfersResponse>,\n  ): Promise<AssetTransfersResponse>;\n}\n\nexport interface TokenAllowanceParams {\n  contract: string;\n  owner: string;\n  spender: string;\n}\n\nexport type TokenAllowanceResponse = string;\n\nexport interface TokenBalancesResponse {\n  address: string;\n  tokenBalances: TokenBalance[];\n}\n\nexport type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;\n\nexport interface TokenBalanceSuccess {\n  address: string;\n  tokenBalance: string;\n  error: null;\n}\n\nexport interface TokenBalanceFailure {\n  address: string;\n  tokenBalance: null;\n  error: string;\n}\n\nexport interface TokenMetadataResponse {\n  decimals: number | null;\n  logo: string | null;\n  name: string | null;\n  symbol: string | null;\n}\n\nexport interface AssetTransfersParams {\n  fromBlock?: string;\n  toBlock?: string;\n  fromAddress?: string;\n  toAddress?: string;\n  contractAddresses?: string[];\n  excludeZeroValue?: boolean;\n  maxCount?: number;\n  category?: AssetTransfersCategory[];\n  pageKey?: string;\n}\n\nexport enum AssetTransfersCategory {\n  EXTERNAL = \"external\",\n  INTERNAL = \"internal\",\n  TOKEN = \"token\",\n}\n\nexport interface AssetTransfersResponse {\n  transfers: AssetTransfersResult[];\n  pageKey?: string;\n}\n\nexport interface AssetTransfersResult {\n  category: AssetTransfersCategory;\n  blockNum: string;\n  from: string;\n  to: string | null;\n  value: number | null;\n  erc721TokenId: string | null;\n  asset: string | null;\n  hash: string;\n  rawContract: RawContract;\n}\n\nexport interface RawContract {\n  value: string | null;\n  address: string | null;\n  decimal: string | null;\n}\n\n/**\n * Same as Eth, but with `subscribe` allowing more types.\n */\nexport interface AlchemyEth extends Eth {\n  subscribe(\n    type: \"logs\",\n    options?: LogsOptions,\n    callback?: (error: Error, log: Log) => void,\n  ): Subscription<Log>;\n  subscribe(\n    type: \"syncing\",\n    options?: null,\n    callback?: (error: Error, result: Syncing) => void,\n  ): Subscription<Syncing>;\n  subscribe(\n    type: \"newBlockHeaders\",\n    options?: null,\n    callback?: (error: Error, blockHeader: BlockHeader) => void,\n  ): Subscription<BlockHeader>;\n  subscribe(\n    type: \"pendingTransactions\",\n    options?: null,\n    callback?: (error: Error, transactionHash: string) => void,\n  ): Subscription<string>;\n  subscribe(\n    type: \"alchemy_fullPendingTransactions\",\n    options?: null,\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type:\n      | \"pendingTransactions\"\n      | \"logs\"\n      | \"syncing\"\n      | \"newBlockHeaders\"\n      | \"alchemy_fullPendingTransactions\",\n    options?: null | LogsOptions,\n    callback?: (\n      error: Error,\n      item: Log | Syncing | BlockHeader | string | Transaction,\n    ) => void,\n  ): Subscription<Log | BlockHeader | Syncing | string>;\n}\n\ninterface EthereumWindow extends Window {\n  ethereum?: any;\n}\n\ndeclare const window: EthereumWindow;\n\nexport function createAlchemyWeb3(\n  alchemyUrl: string,\n  config?: AlchemyWeb3Config,\n): AlchemyWeb3 {\n  const fullConfig = fillInConfigDefaults(config);\n  const { provider, setWriteProvider } = makeAlchemyContext(\n    alchemyUrl,\n    fullConfig,\n  );\n  const alchemyWeb3 = new Web3(provider) as AlchemyWeb3;\n  alchemyWeb3.setProvider = () => {\n    throw new Error(\n      \"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\",\n    );\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  const send = alchemyWeb3.currentProvider.send.bind(\n    alchemyWeb3.currentProvider,\n  );\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: (params: TokenAllowanceParams, callback) =>\n      callAlchemyMethod({\n        send,\n        callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params],\n      }),\n    getTokenBalances: (address, contractAddresses, callback) =>\n      callAlchemyMethod({\n        send,\n        callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses],\n        processResponse: processTokenBalanceResponse,\n      }),\n    getTokenMetadata: (address, callback) =>\n      callAlchemyMethod({\n        send,\n        callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\",\n      }),\n    getAssetTransfers: (params: AssetTransfersParams, callback) =>\n      callAlchemyMethod({\n        send,\n        callback,\n        params: [\n          {\n            ...params,\n            maxCount:\n              params.maxCount != null ? toHex(params.maxCount) : undefined,\n          },\n        ],\n        method: \"alchemy_getAssetTransfers\",\n      }),\n  };\n  patchSubscriptions(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults({\n  writeProvider = getWindowProvider(),\n  maxRetries = DEFAULT_MAX_RETRIES,\n  retryInterval = DEFAULT_RETRY_INTERVAL,\n  retryJitter = DEFAULT_RETRY_JITTER,\n}: AlchemyWeb3Config = {}): FullConfig {\n  return { writeProvider, maxRetries, retryInterval, retryJitter };\n}\n\nfunction getWindowProvider(): Provider | null {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\ninterface CallAlchemyMethodParams<T> {\n  method: string;\n  params: any[];\n  callback?: Web3Callback<T>;\n  send(method: string, params?: any[]): any;\n  processResponse?(response: any): T;\n}\n\nfunction callAlchemyMethod<T>({\n  method,\n  params,\n  send,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyMethodParams<T>): Promise<T> {\n  const promise = (async () => {\n    const result = await send(method, params);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(\n  rawResponse: TokenBalancesResponse,\n): TokenBalancesResponse {\n  // Convert token balance fields from hex-string to decimal-string.\n  const fixedTokenBalances = rawResponse.tokenBalances.map(balance =>\n    balance.tokenBalance != null\n      ? { ...balance, tokenBalance: hexToNumberString(balance.tokenBalance) }\n      : balance,\n  );\n  return { ...rawResponse, tokenBalances: fixedTokenBalances };\n}\n\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\nfunction patchSubscriptions(web3: Web3): void {\n  const { subscriptionsFactory } = web3.eth as any;\n  const oldGetSubscription = subscriptionsFactory.getSubscription.bind(\n    subscriptionsFactory,\n  );\n  subscriptionsFactory.getSubscription = (...args: any[]) => {\n    const [moduleInstance, type] = args;\n    if (type === \"alchemy_fullPendingTransactions\") {\n      return new FullTransactionsSubscription(\n        subscriptionsFactory.utils,\n        subscriptionsFactory.formatters,\n        moduleInstance,\n      );\n    } else {\n      return oldGetSubscription(...args);\n    }\n  };\n}\n\nfunction noop(): void {\n  // Nothing.\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n"]}